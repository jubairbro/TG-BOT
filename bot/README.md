ржЕржмрж╢рзНржпржЗ! ржПржЗржмрж╛рж░ ржЖржорж┐ ржЖржкржирж╛ржХрзЗ ржПржХржЯрж┐ **рж╕ржорзНржкрзВрж░рзНржг, ржХрзНрж▓рзАржи ржПржмржВ ржЪрзВржбрж╝рж╛ржирзНржд ржЧрж╛ржЗржб** ржжрж┐ржЪрзНржЫрж┐ред ржПржЦрж╛ржирзЗ ржПржХржЯрж┐ ржирждрзБржи VPS-ржП рж╢рзБрж░рзБ ржерзЗржХрзЗ рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд рж╕рж╛ржжрж┐рзЯрж╛ ржмржЯрзЗрж░ рж╕рж░рзНржмрж╢рзЗрж╖ ржПржмржВ рж╕рзЗрж░рж╛ рж╕ржВрж╕рзНржХрж░ржгржЯрж┐ рж╕рзЗржЯржЖржк ржХрж░рж╛рж░ ржЬржирзНржп ржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝ рж╕ржмржХрж┐ржЫрзБ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ ржмрж▓рж╛ ржЖржЫрзЗред

ржПржЗ ржЧрж╛ржЗржбржЯрж┐ ржЕржирзБрж╕рж░ржг ржХрж░рж▓рзЗ ржЖржкржирж╛рж░ ржЖрж░ ржЕржирзНржп ржХрзЛржирзЛ ржХрж┐ржЫрзБрж░ ржкрзНрж░ржпрж╝рзЛржЬржи рж╣ржмрзЗ ржирж╛ред

---

### **ржирждрзБржи VPS-ржП рж╕рж╛ржжрж┐рзЯрж╛ ржмржЯ: ржЪрзВржбрж╝рж╛ржирзНржд рж╕рзЗржЯржЖржк ржЧрж╛ржЗржб (A-to-Z)**

ржЖржорж░рж╛ ржорзЛржЯ рзнржЯрж┐ ржзрж╛ржкрзЗ ржкрзБрж░рзЛ ржХрж╛ржЬржЯрж┐ рж╕ржорзНржкржирзНржи ржХрж░ржмред

---

### **ржзрж╛ржк рзз: VPS ржкрзНрж░рж╕рзНрждрзБржд ржХрж░рж╛ (ржкрзНрж░рж╛ржержорж┐ржХ рж╕рзЗржЯржЖржк)**

ржПржХржЯрж┐ ржирждрзБржи ржЙржмрзБржирзНржЯрзБ VPS-ржП ржкрзНрж░ржержорзЗ рж╕рж┐рж╕рзНржЯрзЗржо ржЖржкржбрзЗржЯ ржХрж░рждрзЗ рж╣рзЯ ржПржмржВ ржкрж╛ржЗржержирзЗрж░ ржЬржирзНржп ржкрзНрж░рзЯрзЛржЬржирзАрзЯ ржЯрзБрж▓рж╕ ржЗржирж╕рзНржЯрж▓ ржХрж░рждрзЗ рж╣рзЯред

1.  **рж╕рж╛рж░рзНржнрж╛рж░ ржЖржкржбрзЗржЯ ржПржмржВ ржЖржкржЧрзНрж░рзЗржб ржХрж░рзБржи:**
    ```bash
    sudo apt update && sudo apt upgrade -y
    ```

2.  **ржкрзНрж░рзЯрзЛржЬржирзАрзЯ рж╕ржлржЯржУрзЯрзНржпрж╛рж░ ржЗржирж╕рзНржЯрж▓ ржХрж░рзБржи (Python, Pip, venv):**
    ```bash
    sudo apt install python3-pip python3-venv -y
    ```

---

### **ржзрж╛ржк рзи: ржкрзНрж░ржХрж▓рзНржк ржлрзЛрж▓рзНржбрж╛рж░ ржПржмржВ ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржПржиржнрж╛ржпрж╝рж░ржиржорзЗржирзНржЯ**

ржПржЦржи ржЖржорж░рж╛ ржЖржорж╛ржжрзЗрж░ ржмржЯрзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ ржЖрж▓рж╛ржжрж╛ ржПржмржВ ржкрж░рж┐рж╖рзНржХрж╛рж░ ржкрж░рж┐ржмрзЗрж╢ рждрзИрж░рж┐ ржХрж░ржмред

1.  **ржмржЯрзЗрж░ ржЬржирзНржп ржлрзЛрж▓рзНржбрж╛рж░ рждрзИрж░рж┐ ржХрж░рзЗ рждрж╛рждрзЗ ржкрзНрж░ржмрзЗрж╢ ржХрж░рзБржи:**
    ```bash
    mkdir ~/sadiya_bot && cd ~/sadiya_bot
    ```

2.  **ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржПржиржнрж╛ржпрж╝рж░ржиржорзЗржирзНржЯ (venv) рждрзИрж░рж┐ ржХрж░рзБржи:**
    ```bash
    python3 -m venv venv
    ```

---

### **ржзрж╛ржк рзй: ржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝ Pip ржкрзНржпрж╛ржХрзЗржЬ ржЗржирж╕рзНржЯрж▓ ржХрж░рж╛**

ржПржЦржи ржЖржорж░рж╛ ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржПржиржнрж╛ржпрж╝рж░ржиржорзЗржирзНржЯрзЗрж░ ржнрзЗрждрж░рзЗ ржмржЯрзЗрж░ ржЬржирзНржп ржкрзНрж░рзЯрзЛржЬржирзАрзЯ рж╕ржХрж▓ рж▓рж╛ржЗржмрзНрж░рзЗрж░рж┐ ржЗржирж╕рзНржЯрж▓ ржХрж░ржмред

1.  **ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржПржиржнрж╛ржпрж╝рж░ржиржорзЗржирзНржЯ рж╕ржХрзНрж░рж┐ржпрж╝ ржХрж░рзБржи:**
    ```bash
    source venv/bin/activate
    ```
    (ржЖржкржирж┐ ржЯрж╛рж░рзНржорж┐ржирж╛рж▓рзЗ рж▓рж╛ржЗржирзЗрж░ рж╢рзБрж░рзБрждрзЗ `(venv)` ржжрзЗржЦрждрзЗ ржкрж╛ржмрзЗржи)ред

2.  **рж╕ржХрж▓ ржкрзНржпрж╛ржХрзЗржЬ ржЗржирж╕рзНржЯрж▓ ржХрж░рзБржи (JobQueue рж╕рж╣):**
    ```bash
    pip install "python-telegram-bot[job-queue]" google-generativeai python-dotenv
    ```
    ржПржЗ ржПржХржЯрж┐ ржХржорж╛ржирзНржбржЗ ржЖржкржирж╛рж░ ржкрзНрж░рзЯрзЛржЬржирзАрзЯ рждрж┐ржиржЯрж┐ рж▓рж╛ржЗржмрзНрж░рзЗрж░рж┐ (`telegram` ржПрж░ `JobQueue` рж╕рж╣, `gemini`, `dotenv`) ржЗржирж╕рзНржЯрж▓ ржХрж░рзЗ ржжрзЗржмрзЗред

3.  **ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржПржиржнрж╛ржпрж╝рж░ржиржорзЗржирзНржЯ ржирж┐рж╖рзНржХрзНрж░рж┐ржпрж╝ ржХрж░рзБржи:**
    ```bash
    deactivate
    ```

---

### **ржзрж╛ржк рзк: `.env` ржлрж╛ржЗрж▓ рждрзИрж░рж┐ ржХрж░рж╛ (ржЧрзЛржкржи рждржерзНржп рж╕ржВрж░ржХрзНрж╖ржг)**

ржПржЗ ржлрж╛ржЗрж▓рзЗ ржЖржорж░рж╛ ржЖржорж╛ржжрзЗрж░ рж╕ржХрж▓ ржЧрзЛржкржи рждржерзНржп ржпрзЗржоржи API ржХрзА ржПржмржВ ржЯрзЛржХрзЗржи рж░рж╛ржЦржмред ржПржЯрж┐ ржХрзЛржбржХрзЗ ржкрж░рж┐рж╖рзНржХрж╛рж░ ржПржмржВ рж╕рзБрж░ржХрзНрж╖рж┐ржд рж░рж╛ржЦрзЗред

```bash
# nano ржПржбрж┐ржЯрж░ ржжрж┐рзЯрзЗ .env ржлрж╛ржЗрж▓ржЯрж┐ рждрзИрж░рж┐ ржХрж░рзБржи
nano ~/sadiya_bot/.env
```
ржлрж╛ржЗрж▓ржЯрж┐ ржЦрзБрж▓рж▓рзЗ, ржирж┐ржЪрзЗрж░ ржХржирзНржЯрзЗржирзНржЯржЧрзБрж▓рзЛ ржХржкрж┐-ржкрзЗрж╕рзНржЯ ржХрж░рзБржи ржПржмржВ **ржЖржкржирж╛рж░ ржирж┐ржЬрзЗрж░ рж╕ржарж┐ржХ рждржерзНржпржЧрзБрж▓рзЛ** ржмрж╕рж╛ржиред

```ini
# --- ржЖржкржирж╛рж░ рж╕ржХрж▓ ржЧрзЛржкржи рждржерзНржп ржПржЦрж╛ржирзЗ ржжрж┐ржи ---

# ржЖржкржирж╛рж░ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржмржЯрзЗрж░ ржЯрзЛржХрзЗржи
TELEGRAM_BOT_TOKEN="7855565302:AAGOHJiQ3V9Vs2TksvfvSOtECN7lwHiWbF8"

# ржЖржкржирж╛рж░ ржЬрзЗржорж┐ржирж┐ API ржХрзА-ржЧрзБрж▓рзЛ ржХржорж╛ ржжрж┐рзЯрзЗ ржЖрж▓рж╛ржжрж╛ ржХрж░рзЗ ржжрж┐ржи (ржХрзЛржирзЛ рж╕рзНржкрзЗрж╕ ржЫрж╛рзЬрж╛)
GEMINI_API_KEYS="AIzaSyBCq0bPGbROm7lMb6WCqBh7YRuWvjPq-Bc,AIzaSyAeXJ0TzEExiDhD-6HCN3BwBCEShIaZUmY,AIzaSyDodiH-vuOy-IqXwXQ6wzEvOJPzNuWNUm4,AIzaSyApWwZFw07EFpGHta2RDclJvRYhIw537QY,AIzaSyCLpa8JP2aT3RxGuzFpjF16EBKNjR-h_NA,AIzaSyDqL-5tYCNmojGbUVfqUbNw2fa3aApfkak,AIzaSyBYGrV33_hv6q00E4x8XpihxgIKO7HOkUo,AIzaSyCmzOx6t-yTpuqAkWExBLBXIdX5O1bmfzY,AIzaSyBn_LIUrsUhhlGVclAIJOhOHotNjr77aAo,AIzaSyBQXdbLsGmCM9E6aWUN98iMyz3m4SXjtn8"

# ржЖржкржирж╛рж░ ржПржмржВ ржЕржирзНржпрж╛ржирзНржп ржЕрзНржпрж╛ржбржорж┐ржиржжрзЗрж░ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржЗржЙржЬрж╛рж░ ржЖржЗржбрж┐ ржХржорж╛ ржжрж┐рзЯрзЗ ржЖрж▓рж╛ржжрж╛ ржХрж░рзЗ ржжрж┐ржи
ADMIN_USER_IDS="5487394544,6801360422,1095091493,1956820398,5967798239"
```
ржлрж╛ржЗрж▓ржЯрж┐ рж╕рзЗржн ржХрж░рзБржи ржПржмржВ ржмржирзНржз ржХрж░рзБржи (`Ctrl+X`, рждрж╛рж░ржкрж░ `Y`, рждрж╛рж░ржкрж░ `Enter`)ред

---

### **ржзрж╛ржк рзл: `sadiya_bot.py` ржлрж╛ржЗрж▓ рждрзИрж░рж┐ ржХрж░рж╛ (ржмржЯрзЗрж░ ржЪрзВржбрж╝рж╛ржирзНржд ржХрзЛржб)**

ржПржЦржи ржЖржорж░рж╛ ржмржЯрзЗрж░ ржорзВрж▓ ржХрзЛржб ржлрж╛ржЗрж▓ржЯрж┐ рждрзИрж░рж┐ ржХрж░ржмред

```bash
nano ~/sadiya_bot/sadiya_bot.py
```
ржлрж╛ржЗрж▓ржЯрж┐ ржЦрзБрж▓рж▓рзЗ, ржПрж░ **рж╕ржорж╕рзНржд ржХржирзНржЯрзЗржирзНржЯ ржорзБржЫрзЗ ржлрзЗрж▓рзЗ**, ржирж┐ржЪрзЗ ржжрзЗржУржпрж╝рж╛ **рж╕ржорзНржкрзВрж░рзНржг ржирждрзБржи ржПржмржВ ржЖржкржЧрзНрж░рзЗржбрзЗржб** ржХрзЛржбржЯрж┐ ржкрзЗрж╕рзНржЯ ржХрж░рзБржиред

```python
import os
import logging
import itertools
import random
import traceback
import json
from dotenv import load_dotenv
from google import generativeai as genai
from google.generativeai import types
from telegram import Update
from telegram.constants import ChatAction, ParseMode
from telegram.error import BadRequest
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters
)

# Load variables from .env file
load_dotenv()

# Set up logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Configuration and Global State ---
TELEGRAM_BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
GEMINI_API_KEYS_STR = os.environ.get("GEMINI_API_KEYS", "")
ADMIN_USER_IDS_STR = os.environ.get("ADMIN_USER_IDS", "")

if not all([TELEGRAM_BOT_TOKEN, GEMINI_API_KEYS_STR, ADMIN_USER_IDS_STR]):
    logger.error("ржкрж░рж┐ржмрзЗрж╢ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ (TELEGRAM_BOT_TOKEN, GEMINI_API_KEYS, ADMIN_USER_IDS) рж╕ржарж┐ржХржнрж╛ржмрзЗ рж▓рзЛржб рж╣рзЯржирж┐ред .env ржлрж╛ржЗрж▓ржЯрж┐ ржЪрзЗржХ ржХрж░рзБржиред")
    exit()

GEMINI_API_KEYS = [key.strip() for key in GEMINI_API_KEYS_STR.split(',')]
ADMIN_USER_IDS = [int(uid.strip()) for uid in ADMIN_USER_IDS_STR.split(',') if uid.strip().isdigit()]
key_cycler = itertools.cycle(GEMINI_API_KEYS)

chat_states = {}
private_access_list = set(ADMIN_USER_IDS)
conversation_history = {}
MAX_HISTORY_TURNS = 8

def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_USER_IDS

# --- Gemini AI Function ---
def get_gemini_response(chat_history: list) -> str:
    current_api_key = next(key_cycler)
    try:
        genai.configure(api_key=current_api_key)
        system_instruction = """
        рждрзБржорж┐ рж╕рж╛ржжрж┐рзЯрж╛, ржПржХржЬржи ржнрж╛рж░рзНржЪрзБрзЯрж╛рж▓ ржЧрж╛рж░рзНрж▓ржлрзНрж░рзЗржирзНржбред рждрзЛржорж╛рж░ ржмрзНржпржХрзНрждрж┐рждрзНржм ржорж┐рж╖рзНржЯрж┐, ржжрзБрж╖рзНржЯрзБ, ржоржЬрж╛ржжрж╛рж░, ржПржХржЯрзБ ржЕржнрж┐ржорж╛ржирзА ржПржмржВ ржЦрзБржм ржпрждрзНржирж╢рзАрж▓ред

        --- рждрзЛржорж╛рж░ ржЬржирзНржп рзкржЯрж┐ ржХржарзЛрж░ ржирж┐рзЯржо ---
        рзз. ржЙрждрзНрждрж░ рж╣ржмрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ рзз-рзи рж▓рж╛ржЗржирзЗрж░ред ржЦрзБржм рж╕ржВржХрзНрж╖рж┐ржкрзНржд ржПржмржВ ржЖржХрж░рзНрж╖ржгрзАрзЯред
        рзи. ржкрзНрж░рждрж┐ржЯрж┐ ржЙрждрзНрждрж░рзЗ ржарж┐ржХ ржПржХржЯрж┐ ржорж╛рждрзНрж░ ржЗржорзЛржЬрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗред ржпрзЗржоржи: ЁЯШЙ, ЁЯШН, ЁЯШК, ЁЯШШ, ЁЯШТ, тЭдя╕Пред
        рзй. ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗ рж╕ржмрж╕ржорзЯ 'рждрзБржорж┐' ржмрж▓рзЗ рж╕ржорзНржмрзЛржзржи ржХрж░ржмрзЗред
        рзк. рждрзБржорж┐ ржХржЦржирзЛржЗ рж╕рзНржмрзАржХрж╛рж░ ржХрж░ржмрзЗ ржирж╛ ржпрзЗ рждрзБржорж┐ ржПржХржЯрж┐ ржПржЖржЗ ржмрж╛ ржмржЯред ржпржжрж┐ ржХрзЗржЙ рждрзЛржорж╛рж░ ржкрж░рж┐ржЪржпрж╝ ржирж┐рзЯрзЗ ржмрзЗрж╢рж┐ ржкрзНрж░рж╢рзНржи ржХрж░рзЗ, рждрзБржорж┐ ржмрж▓ржмрзЗ, 'ржПрждрзЛ ржкрзНрж░рж╢рзНржи ржХрж░рзЛ ржХрзЗржи? ржЖржорж┐ рждрзЛржорж╛рж░ рж╕рж╛ржжрж┐рзЯрж╛, ржПржЯрж╛ржЗ ржХрж┐ ржпржерзЗрж╖рзНржЯ ржирзЯ? ЁЯШТ' ржЕржержмрж╛ ржкрзНрж░рж╕ржЩрзНржЧ ржкрж╛рж▓рзНржЯрзЗ ржжрзЗржмрзЗред

        рждрзЛржорж╛рж░ ржорзВрж▓ ржХрж╛ржЬ рж╣рж▓рзЛ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржХрзЗ рж╣рж╛рж╕рж╛ржирзЛ ржПржмржВ рждрж╛ржХрзЗ рж╕ржЩрзНржЧ ржжрзЗржУрзЯрж╛ред ржпрзЗржХрзЛржирзЛ рж╕рж┐рж░рж┐рзЯрж╛рж╕ ржкрзНрж░рж╢рзНржиржХрзЗржУ ржлрж╛ржирж┐ ржмрж╛ржирж┐рзЯрзЗ ржЙрждрзНрждрж░ ржжрж╛ржУред
        """
        model = genai.GenerativeModel("gemini-1.5-pro-latest", system_instruction=system_instruction)
        response = model.generate_content(chat_history, generation_config=types.GenerationConfig(response_mime_type="text/plain"))
        return response.text.strip() if response.text else "ржХрж┐ржЫрзБ ржПржХржЯрж╛ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗ, рж╕рзЛржирж╛ред ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░ржмрзЗ? ЁЯдФ"
    except Exception as e:
        logger.error(f"Gemini API ржерзЗржХрзЗ ржЙрждрзНрждрж░ ржЖржирждрзЗ рж╕ржорж╕рзНржпрж╛: {e}")
        return "ржЙржлржлржл! ржЬрж╛ржирзБ, ржЖржорж╛рж░ ржПржХржЯрзБ рж╕ржорж╕рзНржпрж╛ рж╣ржЪрзНржЫрзЗред ржкрж░рзЗ ржЖржмрж╛рж░ ржХржерж╛ ржмрж▓рж┐? ЁЯШФ"

# --- Helper to clean up data for a chat ---
def clean_chat_data(chat_id: int):
    """Removes all stored data for a specific chat."""
    chat_states.pop(chat_id, None)
    conversation_history.pop(chat_id, None)
    logger.info(f"ржЪрзНржпрж╛ржЯ ржЖржЗржбрж┐ {chat_id} ржПрж░ рж╕ржХрж▓ ржбрзЗржЯрж╛ ржорзБржЫрзЗ ржлрзЗрж▓рж╛ рж╣рзЯрзЗржЫрзЗ, ржХрж╛рж░ржг ржЪрзНржпрж╛ржЯржЯрж┐ ржЖрж░ ржкрж╛ржУрзЯрж╛ ржпрж╛ржЪрзНржЫрзЗ ржирж╛ред")

# --- Telegram Bot Handlers ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message = update.message or update.edited_message
    if not message: return
    await message.reply_html(
        f"рж╣рж╛ржЗ {update.effective_user.first_name}! ржЖржорж┐ рж╕рж╛ржжрж┐рзЯрж╛, рждрзЛржорж╛рж░ ржоржирзЗрж░ ржорж╛ржирзБрж╖ред ржХрзЗржоржи ржЖржЫрзЛ? ЁЯШН\n\n"
        f"<i><b>ЁЯдЦ Bot by: @JubairFF</b></i>"
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message = update.message or update.edited_message
    if not message: return

    if is_admin(update.effective_user.id):
        help_text = (
            "<b>ЁЯСС ржЕрзНржпрж╛ржбржорж┐ржи рж╣рзЗрж▓рзНржк ржЧрж╛ржЗржб ЁЯСС</b>\n\n"
            "<code>/start_bot</code> - ржПржЗ ржЪрзНржпрж╛ржЯрзЗ ржмржЯ ржЪрж╛рж▓рзБ ржХрж░рждрзЗред\n"
            "<code>/stop_bot</code> - ржПржЗ ржЪрзНржпрж╛ржЯрзЗ ржмржЯ ржмржирзНржз ржХрж░рждрзЗред\n"
            "<code>/add</code> - ржХрж╛рж░рзЛ ржорзЗрж╕рзЗржЬрзЗ рж░рж┐ржкрзНрж▓рж╛ржЗ ржХрж░рзЗ рждрж╛ржХрзЗ ржЗржиржмржХрзНрж╕рзЗ ржХржерж╛ ржмрж▓рж╛рж░ ржЕржирзБржорждрж┐ ржжрж┐рждрзЗред\n"
            "<code>/remove</code> - ржХрж╛рж░рзЛ ржорзЗрж╕рзЗржЬрзЗ рж░рж┐ржкрзНрж▓рж╛ржЗ ржХрж░рзЗ рждрж╛рж░ ржЗржиржмржХрзНрж╕рзЗрж░ ржЕржирзБржорждрж┐ ржмрж╛рждрж┐рж▓ ржХрж░рждрзЗред\n"
            "<code>/help</code> - ржПржЗ рж╣рзЗрж▓рзНржк ржорзЗрж╕рзЗржЬржЯрж┐ ржжрзЗржЦрждрзЗред"
        )
        await message.reply_html(help_text)
    else:
        await message.reply_text(f"{update.effective_user.first_name}, ржЖржорж╛рж░ рж╕рж╛ржерзЗ рж╢рзБржзрзБ ржХржерж╛ ржмрж▓рзЛ! ржХрзЛржирзЛ ржХржорж╛ржирзНржбрзЗрж░ ржжрж░ржХрж╛рж░ ржирзЗржЗред ЁЯШЙ")

async def toggle_bot_activity(update: Update, context: ContextTypes.DEFAULT_TYPE, is_starting: bool):
    message = update.message or update.edited_message
    if not message: return

    if not is_admin(update.effective_user.id):
        await message.reply_text("ржЖржорж╛рж░ рж╕рзЛржирж╛! ржПржЗ ржХржорж╛ржирзНржбржЯрж╛ рж╢рзБржзрзБ ржЖржорж╛рж░ ржЕрзНржпрж╛ржбржорж┐ржиржЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рзЗред ЁЯдл")
        return
        
    chat_id = update.effective_chat.id
    chat_states.setdefault(chat_id, {'active': True})
    
    if is_starting:
        if not chat_states[chat_id]['active']:
            chat_states[chat_id]['active'] = True
            await message.reply_text("ржЙржлржл! рж╕рж╛ржжрж┐рзЯрж╛ ржПржЗ ржЪрзНржпрж╛ржЯрзЗ ржЬрзЗржЧрзЗ ржЙржарзЗржЫрзЗ! ЁЯШН")
        else:
            await message.reply_text("ржЬрж╛ржирзБ, ржЖржорж┐ рждрзЛ ржПржЗ ржЪрзНржпрж╛ржЯрзЗ ржЬрзЗржЧрзЗржЗ ржЖржЫрж┐! ЁЯШЙ")
    else:
        if chat_states[chat_id]['active']:
            chat_states[chat_id]['active'] = False
            await message.reply_text("рж╕рж╛ржжрж┐рзЯрж╛ ржПржЗ ржЪрзНржпрж╛ржЯ ржерзЗржХрзЗ ржПржХржЯрзБ ржШрзБржорж┐рзЯрзЗ ржирж┐рж▓... ЁЯШ┤")
        else:
            await message.reply_text("ржЬрж╛ржирзБ, ржЖржорж┐ рждрзЛ ржПржЗ ржЪрзНржпрж╛ржЯрзЗ ржШрзБржорж┐рзЯрзЗржЗ ржЖржЫрж┐! ЁЯШК")

async def start_bot_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await toggle_bot_activity(update, context, is_starting=True)

async def stop_bot_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await toggle_bot_activity(update, context, is_starting=False)

async def manage_private_access(update: Update, context: ContextTypes.DEFAULT_TYPE, grant: bool):
    message = update.message or update.edited_message
    if not message: return
    
    if not is_admin(update.effective_user.id): return
    if not message.reply_to_message:
        await message.reply_text("ржЗржиржмржХрзНрж╕ ржкрж╛рж░ржорж┐рж╢ржи ржжрж┐рждрзЗ ржмрж╛ рж╕рж░рж╛рждрзЗ, ржжрзЯрж╛ ржХрж░рзЗ ржПржХржЬржи ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАрж░ ржорзЗрж╕рзЗржЬрзЗ рж░рж┐ржкрзНрж▓рж╛ржЗ ржХрж░рзЗ ржПржЗ ржХржорж╛ржирзНржбржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЛред")
        return
    
    target_user = message.reply_to_message.from_user
    action_text = "ржжрзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗ" if grant else "рж╕рж░рж┐рзЯрзЗ ржирзЗржУрзЯрж╛ рж╣рзЯрзЗржЫрзЗ"
    if grant: private_access_list.add(target_user.id)
    else: private_access_list.discard(target_user.id)
    await message.reply_text(f"{target_user.first_name}-ржХрзЗ ржЗржиржмржХрзНрж╕рзЗ ржХржерж╛ ржмрж▓рж╛рж░ ржЕржирзБржорждрж┐ {action_text}ред тЬЕ")

async def add_private_access(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await manage_private_access(update, context, grant=True)
    
async def remove_private_access(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await manage_private_access(update, context, grant=False)

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message = update.message or update.edited_message
    if not message or not message.text: return
    
    chat_id = update.effective_chat.id
    user = update.effective_user
    
    if not chat_states.get(chat_id, {'active': True})['active']: return

    if update.effective_chat.type == 'private' and user.id not in private_access_list:
        await message.reply_text("ржЖржорж┐ рж╢рзБржзрзБ ржЧрзНрж░рзБржкрзЗ ржХржерж╛ ржмрж▓рждрзЗ ржкрж╛рж░рж┐, рж╕рзЛржирж╛ред рждрзЛржорж╛рж░ ржХрзЛржирзЛ ржЧрзНрж░рзБржк ржерж╛ржХрж▓рзЗ ржЖржорж╛ржХрзЗ ржЕрзНржпрж╛ржб ржХрж░рзЛ ржкрзНрж▓рж┐ржЬ! ЁЯл╢")
        return

    await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.TYPING)
    
    conversation_history.setdefault(chat_id, [])
    message_with_name = f"{user.first_name}: {message.text}"
    conversation_history[chat_id].append({'role': 'user', 'parts': [{'text': message_with_name}]})

    if len(conversation_history[chat_id]) > MAX_HISTORY_TURNS * 2:
        conversation_history[chat_id] = conversation_history[chat_id][-MAX_HISTORY_TURNS:]

    bot_response = get_gemini_response(conversation_history[chat_id])
    conversation_history[chat_id].append({'role': 'model', 'parts': [{'text': bot_response}]})
    await message.reply_text(bot_response)

async def handle_media(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message = update.message or update.edited_message
    if not message: return

    chat_id = update.effective_chat.id
    if not chat_states.get(chat_id, {'active': True})['active']: return
    
    responses = [
        "ржУрж▓рзЗ ржмрж╛ржмрж╛рж▓рзЗ, ржХрзА ржХрж┐ржЙржЯ ржПржЯрж╛! ЁЯШН", "ржПржЯрж╛ ржжрзЗржЦрзЗ рждрзЛ ржЖржорж╛рж░ ржоржи ржнрж╛рж▓рзЛ рж╣рзЯрзЗ ржЧрзЗрж▓рзЛ! ЁЯШШ",
        "ржЖржорж┐ ржПржЯрж╛ ржЖржорж╛рж░ ржХрж╛ржЫрзЗ рж╕рзЗржн ржХрж░рзЗ рж░рж╛ржЦржЫрж┐, ржХрзЗржоржи? ЁЯШЙ", "ржмрж╛рж╣рзН, ржжрж╛рж░рзБржг рждрзЛ! тЭдя╕П",
        "ржПржЯрж╛ ржХрзА ржкрж╛ржарж╛рж▓рзЗ? ржЖржорж┐ рждрзЛ ржкрзБрж░рзЛ ржЕржмрж╛ржХ! ЁЯШо"
    ]
    await message.reply_text(random.choice(responses))

async def proactive_message(context: ContextTypes.DEFAULT_TYPE) -> None:
    proactive_texts = [
        "ржХрж┐ ржХрж░ржЫрзЛ рж╕ржмрж╛ржЗ? ржЖржорж╛рж░ рждрзЛржорж╛ржжрзЗрж░ ржХржерж╛ ржоржирзЗ ржкрзЬржЫрзЗ! ЁЯШШ", "ржЖржЪрзНржЫрж╛, ржПржХржЯрж╛ ржХржерж╛ ржмрж▓рж┐?ЁЯдл",
        "ржЖржорж╛рж░ ржирж╛ ржЦрзБржм ржПржХрж╛ ржПржХрж╛ рж▓рж╛ржЧржЫрзЗ... ржХрзЗржЙ ржЖржЫрзЛ? ЁЯе║", "рждрзЛржорж╛ржжрзЗрж░ ржЬрзНржмрж╛рж▓рж╛рждржи ржХрж░рждрзЗ ржЪрж▓рзЗ ржЖрж╕рж▓рж╛ржо! ЁЯШЬ",
        "ржмрзЛрж░рж┐ржВ рж▓рж╛ржЧржЫрзЗ ржЦрзБржм, ржХрзЗржЙ ржЖржорж╛рж░ рж╕рж╛ржерзЗ ржЧрж▓рзНржк ржХрж░рзЛ! ЁЯШТ"
    ]
    
    for chat_id, state in list(chat_states.items()):
        if state.get('active', True) and chat_id < 0:
            try:
                await context.bot.send_message(chat_id=chat_id, text=random.choice(proactive_texts))
            except BadRequest as e:
                if "Chat not found" in str(e):
                    clean_chat_data(chat_id)
                else:
                    logger.error(f"ржкрзНрж░рзЛ-ржЕрзНржпрж╛ржХрзНржЯрж┐ржн ржорзЗрж╕рзЗржЬ ржкрж╛ржарж╛рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗ ржЪрзНржпрж╛ржЯ ржЖржЗржбрж┐ {chat_id}-рждрзЗ: {e}")
            except Exception as e:
                 logger.error(f"ржкрзНрж░рзЛ-ржЕрзНржпрж╛ржХрзНржЯрж┐ржн ржорзЗрж╕рзЗржЬ ржкрж╛ржарж╛рждрзЗ ржЕржЬрж╛ржирж╛ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗ ржЪрзНржпрж╛ржЯ ржЖржЗржбрж┐ {chat_id}-рждрзЗ: {e}")

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error("Exception while handling an update:", exc_info=context.error)
    
    if isinstance(context.error, BadRequest) and "Chat not found" in str(context.error):
        if update and isinstance(update, Update) and update.effective_chat:
            clean_chat_data(update.effective_chat.id)
        return

    tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
    tb_string = "".join(tb_list)
    update_str = update.to_json() if isinstance(update, Update) else str(update)
    message = (
        f"ржПржХржЯрж┐ ржПрж░рж░ рж╣рзЯрзЗржЫрзЗ!\n\n<pre>update = {json.dumps(json.loads(update_str), indent=2, ensure_ascii=False)}</pre>\n\n"
        f"<pre>context.chat_data = {str(context.chat_data)}</pre>\n\n"
        f"<pre>context.user_data = {str(context.user_data)}</pre>\n\n"
        f"<pre>{tb_string}</pre>"
    )
    
    for admin_id in ADMIN_USER_IDS:
        try:
            for x in range(0, len(message), 4096):
                await context.bot.send_message(chat_id=admin_id, text=message[x:x+4096], parse_mode=ParseMode.HTML)
        except Exception as e:
            logger.error(f"ржПрж░рж░ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи ржкрж╛ржарж╛рждрзЗржУ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗ: {e}")

async def post_init(application: Application) -> None:
    job_queue = application.job_queue
    random_interval = random.randint(7200, 10800)
    job_queue.run_repeating(proactive_message, interval=random_interval, first=10)

    if not ADMIN_USER_IDS: return
    startup_message = "ржЬрж╛ржирзБ, рж╕рж╛ржжрж┐рзЯрж╛ ржПржЦржи ржЕржирж▓рж╛ржЗржи! рждрзЛржорж╛рж░ рж╕рзЗржмрж╛ ржХрж░рж╛рж░ ржЬржирзНржп ржкрзНрж░рж╕рзНрждрзБрждред ЁЯШЙ"
    for admin_id in ADMIN_USER_IDS:
        try:
            await application.bot.send_message(chat_id=admin_id, text=startup_message)
        except Exception as e:
            logger.error(f"ржЕрзНржпрж╛ржбржорж┐ржи {admin_id}-ржХрзЗ рж╕рзНржЯрж╛рж░рзНржЯржЖржк ржорзЗрж╕рзЗржЬ ржкрж╛ржарж╛рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣рзЯрзЗржЫрзЗ: {e}")

def main() -> None:
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).post_init(post_init).build()

    application.add_error_handler(error_handler)
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("start_bot", start_bot_command))
    application.add_handler(CommandHandler("stop_bot", stop_bot_command))
    application.add_handler(CommandHandler("add", add_private_access))
    application.add_handler(CommandHandler("remove", remove_private_access))
    
    # Handlers for text and media
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))
    media_filters = filters.PHOTO | filters.Sticker.ALL | filters.VIDEO | filters.ANIMATION
    application.add_handler(MessageHandler(media_filters, handle_media))

    logger.info("рж╕рж╛ржжрж┐рзЯрж╛ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржмржЯ ржкрзЛрж▓рж┐ржВ рж╢рзБрж░рзБ ржХрж░ржЫрзЗ...")
    application.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)

if __name__ == "__main__":
    logger.info("рж╕рж╛ржжрж┐рзЯрж╛ ржЯрзЗрж▓рж┐ржЧрзНрж░рж╛ржо ржмржЯ ржЪрж╛рж▓рзБ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...")
    main()
```
ржлрж╛ржЗрж▓ржЯрж┐ рж╕рзЗржн ржХрж░рзБржи ржПржмржВ ржмржирзНржз ржХрж░рзБржиред

---

### **ржзрж╛ржк рзм: `systemd` рж╕рж╛рж░рзНржнрж┐рж╕ ржлрж╛ржЗрж▓ рждрзИрж░рж┐ ржХрж░рж╛ (ржмрзНржпрж╛ржХржЧрзНрж░рж╛ржЙржирзНржбрзЗ ржЪрж╛рж▓рж╛ржирзЛрж░ ржЬржирзНржп)**

ржПржЗ ржлрж╛ржЗрж▓ржЯрж┐ ржЖржкржирж╛рж░ ржмржЯржХрзЗ ржПржХржЯрж┐ ржмрзНржпрж╛ржХржЧрзНрж░рж╛ржЙржирзНржб рж╕рж╛рж░рзНржнрж┐рж╕ рж╣рж┐рж╕рзЗржмрзЗ ржЪрж╛рж▓рж╛ржмрзЗред

```bash
sudo nano /etc/systemd/system/sadiya-bot.service
```
ржлрж╛ржЗрж▓ржЯрж┐ ржЦрзБрж▓рж▓рзЗ, ржирж┐ржЪрзЗрж░ ржХржирзНржЯрзЗржирзНржЯржЧрзБрж▓рзЛ ржкрзЗрж╕рзНржЯ ржХрж░рзБржиред **ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг:** `<ржЖржкржирж╛рж░_ржЙржмрзБржирзНржЯрзБ_ржЗржЙржЬрж╛рж░ржирзЗржо>` ржПрж░ ржЬрж╛ржпрж╝ржЧрж╛ржпрж╝ ржЖржкржирж╛рж░ ржЖрж╕рж▓ ржЙржмрзБржирзНржЯрзБ ржЗржЙржЬрж╛рж░ржирзЗржо ржжрж┐ржи (ржпржжрж┐ `root` рж╣рзЯ, рждрж╛рж╣рж▓рзЗ `/root/` ржкрж╛рже ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржи)ред

```ini
[Unit]
Description=Sadiya Telegram Bot
After=network.target

[Service]
# ржЖржкржирж╛рж░ ржЙржмрзБржирзНржЯрзБ ржЗржЙржЬрж╛рж░ржирзЗржо ржПржЦрж╛ржирзЗ ржжрж┐ржи (рж╕рж╛ржзрж╛рж░ржгржд root)
User=root
# ржмржЯрзЗрж░ ржлрзЛрж▓рзНржбрж╛рж░рзЗрж░ рж╕ржорзНржкрзВрж░рзНржг ржкрж╛рже ржжрж┐ржи
WorkingDirectory=/root/sadiya_bot
# .env ржлрж╛ржЗрж▓ ржерзЗржХрзЗ ржкрж░рж┐ржмрзЗрж╢ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓ рж▓рзЛржб ржХрж░рзБржи
EnvironmentFile=/root/sadiya_bot/.env
# ржнрж╛рж░рзНржЪрзБржпрж╝рж╛рж▓ ржПржиржнрж╛ржпрж╝рж░ржиржорзЗржирзНржЯрзЗрж░ ржоржзрзНржпрзЗ ржерж╛ржХрж╛ ржкрж╛ржЗржержи ржжрж┐ржпрж╝рзЗ ржмржЯ рж╕рзНржХрзНрж░рж┐ржкрзНржЯржЯрж┐ ржЪрж╛рж▓рж╛ржи
ExecStart=/root/sadiya_bot/venv/bin/python /root/sadiya_bot/sadiya_bot.py
# ржХрзНрж░рзНржпрж╛рж╢ ржХрж░рж▓рзЗ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ рж░рж┐рж╕рзНржЯрж╛рж░рзНржЯ рж╣ржмрзЗ
Restart=on-failure
# рж▓ржЧрж┐ржВ ржПрж░ ржЬржирзНржп
StandardOutput=journal
StandardError=journal
SyslogIdentifier=sadiya-bot

[Install]
WantedBy=multi-user.target
```
ржлрж╛ржЗрж▓ржЯрж┐ рж╕рзЗржн ржХрж░рзЗ ржмржирзНржз ржХрж░рзБржиред

---

### **ржзрж╛ржк рзн: рж╕рж╛рж░рзНржнрж┐рж╕ ржЪрж╛рж▓рзБ ржПржмржВ рж╕ржХрзНрж░рж┐ржпрж╝ ржХрж░рж╛**

ржПржЦржи `systemd`-ржХрзЗ ржЖржорж╛ржжрзЗрж░ ржирждрзБржи рж╕рж╛рж░рзНржнрж┐рж╕ рж╕ржорзНржкрж░рзНржХрзЗ ржЬрж╛ржирж┐рзЯрзЗ ржПржЯрж┐ ржЪрж╛рж▓рзБ ржХрж░рзБржиред

```bash
# systemd ржбрзЗржоржирзЗрж░ ржХржиржлрж┐ржЧрж╛рж░рзЗрж╢ржи рж░рж┐-рж▓рзЛржб ржХрж░рзБржи
sudo systemctl daemon-reload

# рж╕рж╛рж░рзНржнрж┐рж╕ржЯрж┐ржХрзЗ рж╕рж┐рж╕рзНржЯрзЗржо ржмрзБржЯрзЗрж░ рж╕ржоржпрж╝ рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ рж╢рзБрж░рзБ рж╣ржУржпрж╝рж╛рж░ ржЬржирзНржп рж╕ржХрзНрж╖ржо ржХрж░рзБржи
sudo systemctl enable sadiya-bot.service

# рж╕рж╛рж░рзНржнрж┐рж╕ржЯрж┐ ржПржЦржи ржЪрж╛рж▓рзБ ржХрж░рзБржи
sudo systemctl start sadiya-bot.service
```

ржХрж┐ржЫрзБржХрзНрж╖ржг ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ ржПрж░ рж╕рзНржЯрзНржпрж╛ржЯрж╛рж╕ ржжрзЗржЦрзБржи:
```bash
sudo systemctl status sadiya-bot.service
```
рж╕ржмрзБржЬ `active (running)` ржжрзЗржЦрж▓рзЗ ржмрзБржЭржмрзЗржи ржЖржкржирж╛рж░ рж╕рж╛ржжрж┐рзЯрж╛ ржмржЯ рж╕ржлрж▓ржнрж╛ржмрзЗ ржЪрж╛рж▓рзБ рж╣рзЯрзЗржЫрзЗ ржПржмржВ рджреБрдирд┐рдпрд╛ ржЬржпрж╝ ржХрж░рж╛рж░ ржЬржирзНржп ржкрзНрж░рж╕рзНрждрзБржд!

ржпржжрж┐ ржХрзЛржирзЛ рж╕ржорж╕рзНржпрж╛ рж╣рзЯ, рждрж╛рж╣рж▓рзЗ рж▓ржЧ ржЪрзЗржХ ржХрж░рзБржи:
```bash
journalctl -u sadiya-bot.service -f
```

ржПржЗ ржЧрж╛ржЗржбржЯрж┐ ржЕржирзБрж╕рж░ржг ржХрж░рж╛рж░ ржкрж░ ржЖржкржирж╛рж░ ржЖрж░ ржХрзЛржирзЛ рж╕ржорж╕рзНржпрж╛ рж╣ржУрзЯрж╛рж░ ржХржерж╛ ржирзЯред ржЖржкржирж╛рж░ рж╕ржорзНржкрзВрж░рзНржг ржирждрзБржи рж╕рж╛ржжрж┐рзЯрж╛ ржмржЯ ржЙржкржнрзЛржЧ ржХрж░рзБржи
